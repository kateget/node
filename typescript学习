该文为学习总结与简述
-------------------------------------------------------------------------
1.typescript 安装
npm install typescript -g
-------------------------------------------------------------------------
2.ts-node 安装与使用
npm install -g ts-node
运行ts代码
ts-node Demo1.ts
-------------------------------------------------------------------------
参考技术胖文章---https://juejin.im/post/6876240277208563720
基础：
== 1.常量
const count: number = 1
== 自定义静态类型
interface XiaoJieJie {
  uname: string;
  age: number;
}

const xiaohong: XiaoJieJie = {
  uname: "小红",
  age: 18,
};
== 2.对象类型
== 2.1对象类型
const teacher: {
    userName: string,
    age: number
} = {
    userName: 'demo',
    age: 18
}
== 2.2数组
const arr: string[] = ['demo1','demo2'] // 必须是字符串的数组
== 2.3类的形式定义变量
const Person {}
const demo: Person = new Person();
== 2.4函数类型定义变量
const demo: () => string = () => {
  return "大脚";
};
-------------------------------------------------------------------------
类型注解和类型推断
let count: number
count = 1
明确指出当前类型为数字，这种就叫类型注解
let count = 123
把鼠标放上去，ts把变量注释为数字类型，这种就是类型推断
-------------------------------------------------------------------------
函数返回和返回类型定义
== 1.简单类型定义
function getTotal(one: number, two: number): number {
  return one + two;
}

const total = getTotal(1, 2);
设置返回值类型
== 2.函数无返回值时定义方法
function sayHello(): void {
  console.log("hello world");
}
如果这样定义后，你再加入任何返回值，程序都会报错。
== never 返回值类型
如果一个函数是永远也执行不完的，就可以定义返回值为never，那什么样的函数是永远也执行不完的那?我们先来写一个这样的函数(比如执行执行的时候，抛出了异常，这时候就无法执行完了)。
function errorFuntion(): never {
  throw new Error();
  console.log("Hello World");
}
还有一种是一直循环，也是我们常说的死循环，这样也运行不完，比如下面的代码：
function forNever(): never {
  while (true) {}
  console.log("Hello JSPang");
}
== 函数参数为对象(解构)时
function add({ one: number, two: number }) {
  return one + two;
}

const total = add({ one: 1, two: 2 });
这种写法是错误的
*******
正确写法：
function add({ one, two }: { one: number, two: number }): number {
  return one + two;
}

const three = add({ one: 1, two: 2 })

function getNumber({ one }: { one: number }): number {
  return one;
}

const one = getNumber({ one: 1 });
-------------------------------------------------------------------------
TypeScript 中数组类型的定义
== 1.一般数组类型的定义
const numberArr = [1, 2, 3];
这个时候类型是ts自己推断出来的
const numberArr: number[] = [1, 2, 3];
== 2.多类型数组
const arr: (number | string)[] = [1, "string", 2];
== 3.数组中对象类型的定义
3.1 类型别名
type Lady = { name: string, age: Number }; 类型别名必须以type开头
或者： class Lady = { name: string, age: Number }; 用类定义也是可以的，效果与别名一样

const xiaoJieJies: Lady[] = [
  { name: "刘英", age: 18 },
  { name: "谢大脚", age: 28 },
];
3.2 元组的基本应用
const xiaojiejie: (string | number)[] = ["dajiao", 28, "teacher"];
普通数组，并不能区分每个位置的元素类型,即使这样写，依然不会报错
const xiaojiejie: [string, string, number] = ["dajiao", "teacher", 28];
元组能很好的限制相应位置的元素类别，如果需要使用严谨的结构，可以使用元组
-------------------------------------------------------------------------
TypeScript 中的 interface 接口
== 1.Interface 接口初步了解
重复的注解可以提出来写出一个接口
interface Girl {
  name: string;
  age: number;
  bust: number;
}
const screenResume = (girl: Girl) => {
  girl.age < 24 && girl.bust >= 90 && console.log(girl.name + "进入面试");
  girl.age > 24 || (girl.bust < 90 && console.log(girl.name + "你被淘汰"));
};

const getResume = (girl: Girl) => {
  console.log(girl.name + "年龄是：" + girl.age);
  console.log(girl.name + "胸围是：" + girl.bust);
};
const girl = {
  name: "大脚",
  age: 18,
  bust: 94,
};

screenResume(girl);
getResume(girl);
== 2.接口和类型别名的区别
类型别名可以直接给类型，比如string，而接口必须代表对象。
例如：
别名---
type Girl1 = stirng;
接口---只能写成
const girl = {
  name: "大脚",
  age: 18,
  bust: 94,
};
== 3.接口非必选值得定义
interface Girl {
  name: string;
  age: number;
  bust: number;
  waistline?: number;
}
waistline 就为可选值
== 4.允许加入任意值
interface Girl {
  name: string;
  age: number;
  bust: number;
  waistline?: number;
  [propname: string]: any;
}
意思：属性的名称是字符串，值为任意类型
const girl = {
  name: "大脚",
  age: 18,
  bust: 94,
  waistline: 21,
  sex: "女",
};
相应的对象可以为上述
== 5.接口里的方法
interface Girl {
  name: string;
  age: number;
  bust: number;
  waistline?: number;
  [propname: string]: any;
  say(): string;
}
== 6.接口和类的约束
class XiaoJieJie implements Girl {}
这样写会报错，需要把类写完整点
class XiaoJieJie implements Girl {
  name = "刘英";
  age = 18;
  bust = 90;
  say() {
    return "欢迎光临 ，红浪漫洗浴！！";
  }
}
== 7.接口继承
interface Teacher extends Girl {
  teach(): string;
}
-------------------------------------------------------------------------
TypeScript 中类的概念和使用

== 1.类的基本使用
class Lady {
  content = "Hi，帅哥";
  sayHello() {
    return this.content;
  }
}

const goddess = new Lady();
console.log(goddess.sayHello());
== 2.类的继承
class Lady {
  content = "Hi，帅哥";
  sayHello() {
    return this.content;
  }
}
class XiaoJieJie extends Lady {
  sayLove() {
    return "I love you";
  }
}

const goddess = new XiaoJieJie();
console.log(goddess.sayHello());
console.log(goddess.sayLove());

== 3.类的重写
class XiaoJieJie extends Lady {
  sayLove() {
    return "I love you!";
  }
  sayHello() {
    return "Hi , honey!";
  }
}
== 4.super 关键字的使用
super代表父类的方法
class XiaoJieJie extends Lady {
  sayLove() {
    return "I love you!";
  }
  sayHello() {
    return super.sayHello() + "。你好！";
  }
}
-------------------------------------------------------------------------
TypeScript 中类的访问类型
1.public
2.private
3.protected
-------------------------------------------------------------------------
TypeScript 类的构造函数

1.类的构造函数
class Person{
    constructor(public name:string){
    }
}

const person= new Person('jspang')
console.log(person.name)
构造函数定义后，赋值
2.类继承中的构造器写法
子类如果有构造函数就必须用super调用父元素的构造函数
class Person{}

class Teacher extends Person{
    constructor(public age:number){
        super()
    }
}

const teacher = new Teacher(18)
console.log(teacher.age)

-------------------------------------------------------------------------
TypeScript 类的 Getter、Setter 和 static 使用

== 1.类的 Getter 和 Setter
类中似有属性只能通过getter和setter来获取与设置
class Xiaojiejie {
  constructor(private _age:number){}
  get age(){
      return this._age-10
  }
  set age(age:number){
    this._age=age
  }
}

const dajiao = new Xiaojiejie(28)
dajiao.age=25
console.log(dajiao.age)
== 2.类中的 static
class Girl {
  static sayLove() {
    return "I Love you";
  }
}
console.log(Girl.sayLove());
静态方法可以通过方法直接调用
-------------------------------------------------------------------------
类的只读属性和抽象类

== 1.类里的只读属性 readonly

class Person {
    public readonly _name :string;
    constructor(name:string ){
        this._name = name;
    }
}

const person = new Person('jspang')
person._name= '谢广坤' //报错
console.log(person._name)

只读属性，只能读取，不能更改，否者会报错

== 2.抽象类的使用
// 抽象类开头关键字为 abstract 
abstract class Girl{
    abstract skill()  //因为没有具体的方法，所以我们这里不写括号

}

class Waiter extends Girl{
    skill(){
        console.log('大爷，请喝水！')
    }
}

class BaseTeacher extends Girl{
    skill(){
        console.log('大爷，来个泰式按摩吧！')
    }
}

class seniorTeacher extends Girl{
    skill(){
        console.log('大爷，来个SPA全身按摩吧！')
    }
}

-------------------------------------------------------------------------
配置文件-初识 tsconfig.json
== 1.生成 tsconfig.json 文件
通过命令" tsc --init " 生成 tsconfig.json 配置文件
tsc demo.ts 运行文件会生成编译后的js文件,这个时候tsconfig.json不会起作用，运行tsc后，配置文件才会生效
ts-node 只运行，不编译
== 2.include 、exclude 和 files

